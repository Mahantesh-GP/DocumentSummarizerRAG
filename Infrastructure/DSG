[ApiController]
[Route("api/[controller]")]
public class SearchController : ControllerBase
{
    private readonly AzureSearchService _searchService;

    public SearchController(AzureSearchService searchService)
    {
        _searchService = searchService;
    }

    [HttpGet]
    public async Task<IActionResult> Search([FromQuery] string query)
    {
        var results = await _searchService.HybridSearchAsync(query);
        return Ok(results);
    }
}
[ApiController]
[Route("api/[controller]")]
public class DocumentController : ControllerBase
{
    private readonly BlobStorageService _blobService;
    private readonly AzureSearchService _searchService;

    public DocumentController(BlobStorageService blobService, AzureSearchService searchService)
    {
        _blobService = blobService;
        _searchService = searchService;
    }

    [HttpDelete]
    public async Task<IActionResult> Delete([FromQuery] string blobUrl)
    {
        await _blobService.DeleteBlobAsync(blobUrl);
        return NoContent();
    }

    [HttpPost("status")]
    public async Task<IActionResult> UpdateStatus([FromBody] DocumentStatusRequest request)
    {
        await _searchService.UpdateStatusAsync(request);
        return Ok();
    }
}

public class DocumentStatusRequest
{
    public string BlobUrl { get; set; }
    public bool IsReviewed { get; set; }
    public bool IsDeleted { get; set; }
}

using Azure;
using Azure.Search.Documents;
using Azure.Search.Documents.Indexes;
using Azure.Search.Documents.Models;
using Microsoft.Extensions.Configuration;

public class AzureSearchService
{
    private readonly IConfiguration _config;
    private readonly SearchClient _searchClient;

    public AzureSearchService(IConfiguration config)
    {
        _config = config;
        var endpoint = new Uri(_config["AzureSearch:Endpoint"]);
        var credential = new AzureKeyCredential(_config["AzureSearch:ApiKey"]);
        _searchClient = new SearchClient(endpoint, _config["AzureSearch:IndexName"], credential);
    }

    public async Task<List<RelatedDocGroup>> HybridSearchAsync(string query)
    {
        var options = new SearchOptions { Size = 20 };
        options.Select.Add("processId");
        options.Select.Add("summary");
        options.Select.Add("blobUrl");
        options.Select.Add("documentType");
        options.Select.Add("groupType");
        options.Select.Add("isReviewed");
        options.Select.Add("isDeleted");

        var results = await _searchClient.SearchAsync<SearchDocument>(query, options);
        var grouped = new Dictionary<string, RelatedDocGroup>();

        await foreach (var item in results.Value.GetResultsAsync())
        {
            var doc = item.Document;
            var processId = doc["processId"]?.ToString() ?? "unknown";

            if (!grouped.ContainsKey(processId))
            {
                grouped[processId] = new RelatedDocGroup
                {
                    ProcessId = processId,
                    Summary = doc["summary"]?.ToString(),
                    Documents = new List<RelatedDoc>()
                };
            }

            grouped[processId].Documents.Add(new RelatedDoc
            {
                Name = Path.GetFileName(doc["blobUrl"]?.ToString()),
                Url = doc["blobUrl"]?.ToString(),
                Type = doc["documentType"]?.ToString(),
                IsReviewed = doc.ContainsKey("isReviewed") && (bool)doc["isReviewed"],
                IsDeleted = doc.ContainsKey("isDeleted") && (bool)doc["isDeleted"]
            });
        }

        return grouped.Values.ToList();
    }

    public async Task UpdateStatusAsync(DocumentStatusRequest request)
    {
        var patch = new Dictionary<string, object>
        {
            ["@search.action"] = "merge",
            ["blobUrl"] = request.BlobUrl,
            ["isReviewed"] = request.IsReviewed,
            ["isDeleted"] = request.IsDeleted
        };

        await _searchClient.MergeOrUploadDocumentsAsync(new[] { patch });
    }
}

public class RelatedDocGroup
{
    public string ProcessId { get; set; }
    public string Summary { get; set; }
    public List<RelatedDoc> Documents { get; set; }
}

public class RelatedDoc
{
    public string Name { get; set; }
    public string Url { get; set; }
    public string Type { get; set; }
    public bool IsReviewed { get; set; }
    public bool IsDeleted { get; set; }
}

public class DocumentStatusRequest
{
    public string BlobUrl { get; set; }
    public bool IsReviewed { get; set; }
    public bool IsDeleted { get; set; }
}


using Azure;
using Azure.AI.OpenAI;
using Azure.Search.Documents;
using Azure.Search.Documents.Indexes;
using Azure.Search.Documents.Models;
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class HybridSearchController : ControllerBase
{
    private readonly IConfiguration _config;

    public HybridSearchController(IConfiguration config)
    {
        _config = config;
    }

    [HttpPost("search")]
    public async Task<IActionResult> SearchAsync([FromBody] SearchRequest request)
    {
        string searchEndpoint = _config["AZURE_SEARCH_ENDPOINT"];
        string searchKey = _config["AZURE_SEARCH_KEY"];
        string openAiEndpoint = _config["AZURE_OPENAI_ENDPOINT"];
        string openAiKey = _config["AZURE_OPENAI_KEY"];

        var searchClient = new SearchClient(new Uri(searchEndpoint), "document-index", new AzureKeyCredential(searchKey));

        var embeddingVector = await GetEmbeddingAsync(request.Query, openAiEndpoint, openAiKey);

        var options = new SearchOptions
        {
            Size = 20,
            QueryType = SearchQueryType.Simple,
            VectorSearch = new VectorSearch
            {
                Queries =
                {
                    new VectorQuery
                    {
                        Fields = { "contentVector" },
                        Value = embeddingVector,
                        KNearestNeighborsCount = 10
                    }
                }
            }
        };

        var filters = new List<string>();
        if (!string.IsNullOrEmpty(request.AppId))
            filters.Add($"appId eq '{request.AppId}'");
        if (!string.IsNullOrEmpty(request.PropertyKey))
            filters.Add($"propertyKey eq '{request.PropertyKey}'");
        if (!string.IsNullOrEmpty(request.DocumentType))
            filters.Add($"documentType eq '{request.DocumentType}'");

        if (filters.Any())
            options.Filter = string.Join(" and ", filters);

        var response = await searchClient.SearchAsync<SearchDocument>(request.Query, options);
        var results = response.Value.GetResults().Select(r => r.Document);

        return Ok(results);
    }

    private async Task<IReadOnlyList<float>> GetEmbeddingAsync(string query, string endpoint, string key)
    {
        var client = new OpenAIClient(new Uri(endpoint), new AzureKeyCredential(key));
        var response = await client.GetEmbeddingsAsync("text-embedding-ada-002", new EmbeddingsOptions(query));
        return response.Value.Data[0].Embedding;
    }
}

public class SearchRequest
{
    public string Query { get; set; }
    public string AppId { get; set; }
    public string PropertyKey { get; set; }
    public string DocumentType { get; set; }
}


