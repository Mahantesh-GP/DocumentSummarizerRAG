using System.Text.RegularExpressions;
using Azure;
using Azure.AI.OpenAI;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json.Linq;
using System.Net.Http;

public static class ExtractAndTagFields
{
    [FunctionName("ExtractAndTagFields")]
    public static async Task<IActionResult> Run(
        [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req,
        ILogger log)
    {
        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
        var input = JObject.Parse(requestBody);
        var record = input["values"]?[0];
        string recordId = record?["recordId"]?.ToString();

        var data = record?["data"] as JObject;
        var chunks = data?["chunks"]?.ToObject<List<string>>() ?? new List<string>();
        string fullText = string.Join("\n\n", chunks);
        string limitedText = fullText.Length > 3000 ? fullText[..3000] : fullText;

        var extractedFields = await ExtractFieldsUsingOpenAI(limitedText, log);
        var cleanedFields = PostProcessFields(extractedFields, log, fullText);

        var response = new
        {
            values = new[]
            {
                new
                {
                    recordId = recordId,
                    data = cleanedFields
                }
            }
        };

        return new OkObjectResult(response);
    }

    private static async Task<Dictionary<string, object>> ExtractFieldsUsingOpenAI(string text, ILogger log)
    {
        var client = new OpenAIClient(
            new Uri(Environment.GetEnvironmentVariable("AZURE_OPENAI_ENDPOINT")),
            new AzureKeyCredential(Environment.GetEnvironmentVariable("AZURE_OPENAI_KEY")));

        var chat = new ChatCompletionsOptions()
        {
            Messages =
            {
                new ChatMessage(ChatRole.System, "Extract the following fields if present: policyNumber, orderNumber, propertyAddress, closingDate, borrowerName, sellerName, buyerName, policyDate. Return only a JSON object with those keys."),
                new ChatMessage(ChatRole.User, text)
            },
            Temperature = 0.3f,
            MaxTokens = 512
        };

        try
        {
            var completion = await client.GetChatCompletionsAsync("gpt-35-turbo", chat);
            var json = completion.Value.Choices[0].Message.Content;
            return JsonConvert.DeserializeObject<Dictionary<string, object>>(json);
        }
        catch (Exception ex)
        {
            log.LogWarning($"OpenAI call failed: {ex.Message}");
            return new();
        }
    }

    private static Dictionary<string, object> PostProcessFields(Dictionary<string, object> extracted, ILogger log, string rawText)
    {
        var cleaned = new Dictionary<string, object>();

        // Copy over extracted fields directly
        foreach (var key in new[] { "policyNumber", "orderNumber", "propertyAddress", "closingDate", "borrowerName", "sellerName", "buyerName", "policyDate" })
        {
            cleaned[key] = extracted.ContainsKey(key) ? extracted[key] : null;
        }

        // Fallback regex
        if (!string.IsNullOrWhiteSpace(rawText))
        {
            cleaned["policyNumber"] ??= MatchOrNull(rawText, "Policy\\s*Number[:\\-\\s]*([\\w\\-/]+)");
            cleaned["orderNumber"] ??= MatchOrNull(rawText, "Order\\s*Number[:\\-\\s]*([\\w\\-/]+)");
            cleaned["propertyAddress"] ??= MatchOrNull(rawText, "Property\\s*Address[:\\-\\s]*(.+?)(\\n|$)");
            cleaned["borrowerName"] ??= MatchOrNull(rawText, "Borrower[:\\-\\s]*(.+?)(\\n|$)");
            cleaned["buyerName"] ??= MatchOrNull(rawText, "Buyer[:\\-\\s]*(.+?)(\\n|$)");
            cleaned["sellerName"] ??= MatchOrNull(rawText, "Seller[:\\-\\s]*(.+?)(\\n|$)");
            cleaned["closingDate"] ??= MatchOrNull(rawText, "Closing\\s*Date[:\\-\\s]*([\\d]{2}/[\\d]{2}/[\\d]{4})");
            cleaned["policyDate"] ??= MatchOrNull(rawText, "Policy\\s*Date[:\\-\\s]*([\\d]{2}/[\\d]{2}/[\\d]{4})");
        }

        return cleaned;
    }

    private static string MatchOrNull(string input, string pattern)
    {
        var match = Regex.Match(input, pattern, RegexOptions.IgnoreCase);
        return match.Success ? match.Groups[1].Value.Trim() : null;
    }
}
